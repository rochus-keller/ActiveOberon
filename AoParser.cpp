// This file was automatically generated by EbnfStudio; don't modify it!
#include "AoParser.h"
using namespace Ao;

static inline bool FIRST_Module(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_ImportDecl(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ImportList(int tt) {
	return tt == Tok_IMPORT;
}

static inline bool FIRST_DeclSeq(int tt) {
	return tt == Tok_CONST || tt == Tok_PROCEDURE || tt == Tok_TYPE || tt == Tok_VAR;
}

static inline bool FIRST_ObjectDeclSeq(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_VAR;
}

static inline bool FIRST_ConstDecl(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_TypeDecl(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_VarDecl(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_Assembler(int tt) {
	return tt == Tok_CODE;
}

static inline bool FIRST_ProcDecl(int tt) {
	return tt == Tok_PROCEDURE;
}

static inline bool FIRST_ProcHead(int tt) {
	return tt == Tok_ident || tt == Tok_Minus || tt == Tok_Amp || tt == Tok_Star || tt == Tok_Lbrack;
}

static inline bool FIRST_SysFlag(int tt) {
	return tt == Tok_Lbrack;
}

static inline bool FIRST_FormalPars(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_FPSection(int tt) {
	return tt == Tok_ident || tt == Tok_VAR;
}

static inline bool FIRST_ArrayType(int tt) {
	return tt == Tok_ARRAY;
}

static inline bool FIRST_RecordType(int tt) {
	return tt == Tok_RECORD;
}

static inline bool FIRST_PointerType(int tt) {
	return tt == Tok_POINTER;
}

static inline bool FIRST_ObjectType(int tt) {
	return tt == Tok_OBJECT;
}

static inline bool FIRST_ProcedureType(int tt) {
	return tt == Tok_PROCEDURE;
}

static inline bool FIRST_AliasType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_Type(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_PROCEDURE:
	case Tok_POINTER:
	case Tok_ARRAY:
	case Tok_OBJECT:
	case Tok_RECORD:
		return true;
	default: return false;
	}
}

static inline bool FIRST_FieldDecl(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_FieldList(int tt) {
	return tt == Tok_ident || tt == Tok_Semi;
}

static inline bool FIRST_Body(int tt) {
	return tt == Tok_BEGIN;
}

static inline bool FIRST_Attributes(int tt) {
	return tt == Tok_Lbrace;
}

static inline bool FIRST_Attribute(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_StatBlock(int tt) {
	return tt == Tok_BEGIN;
}

static inline bool FIRST_StatSeq(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_REPEAT:
	case Tok_Semi:
	case Tok_CASE:
	case Tok_WITH:
	case Tok_EXIT:
	case Tok_IF:
	case Tok_FOR:
	case Tok_WHILE:
	case Tok_BEGIN:
	case Tok_RETURN:
	case Tok_LOOP:
		return true;
	default: return false;
	}
}

static inline bool FIRST_AssigOrCall(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_IfStat(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_CaseStat(int tt) {
	return tt == Tok_CASE;
}

static inline bool FIRST_WhileStat(int tt) {
	return tt == Tok_WHILE;
}

static inline bool FIRST_RepeatStat(int tt) {
	return tt == Tok_REPEAT;
}

static inline bool FIRST_ForStat(int tt) {
	return tt == Tok_FOR;
}

static inline bool FIRST_LoopStat(int tt) {
	return tt == Tok_LOOP;
}

static inline bool FIRST_WithStat(int tt) {
	return tt == Tok_WITH;
}

static inline bool FIRST_ReturnStat(int tt) {
	return tt == Tok_RETURN;
}

static inline bool FIRST_Statement(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_REPEAT:
	case Tok_CASE:
	case Tok_WITH:
	case Tok_IF:
	case Tok_EXIT:
	case Tok_FOR:
	case Tok_WHILE:
	case Tok_BEGIN:
	case Tok_LOOP:
	case Tok_RETURN:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Case(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_CaseLabels(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ConstExpr(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Expr(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_SimpleExpr(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Term(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Factor(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Set(int tt) {
	return tt == Tok_Lbrace;
}

static inline bool FIRST_Element(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Relation(int tt) {
	switch(tt){
	case Tok_Hash:
	case Tok_Eq:
	case Tok_Leq:
	case Tok_Lt:
	case Tok_IN:
	case Tok_Gt:
	case Tok_Geq:
	case Tok_IS:
		return true;
	default: return false;
	}
}

static inline bool FIRST_MulOp(int tt) {
	return tt == Tok_Amp || tt == Tok_Slash || tt == Tok_DIV || tt == Tok_MOD || tt == Tok_Star;
}

static inline bool FIRST_AddOp(int tt) {
	return tt == Tok_Minus || tt == Tok_OR || tt == Tok_Plus;
}

static inline bool FIRST_Designator(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_Selector(int tt) {
	return tt == Tok_Hat || tt == Tok_Dot || tt == Tok_Lpar || tt == Tok_Lbrack;
}

static inline bool FIRST_ExprList(int tt) {
	switch(tt){
	case Tok_ident:
	case Tok_Lbrace:
	case Tok_hexchar:
	case Tok_string:
	case Tok_Minus:
	case Tok_integer:
	case Tok_NIL:
	case Tok_real:
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_Tilde:
		return true;
	default: return false;
	}
}

static inline bool FIRST_IdentList(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_Qualident(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_IdentDef(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_number(int tt) {
	return tt == Tok_integer || tt == Tok_real;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	Module(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		if( cur.d_type != Tok_Semi && cur.d_type != Tok_Comma && cur.d_type != Tok_Dot && cur.d_type != Tok_Colon ){
			SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
		}
	}
void Parser::Module(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Module, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_MODULE, false, "Module") ) addTerminal(st);
	if( expect(Tok_ident, false, "Module") ) addTerminal(st);
	if( expect(Tok_Semi, false, "Module") ) addTerminal(st);
	if( FIRST_ImportList(la.d_type) ) {
		ImportList(st);
	}
	DeclSeq(st);
	if( FIRST_Body(la.d_type) ) {
		Body(st);
	}
	if( expect(Tok_END, false, "Module") ) addTerminal(st);
	if( expect(Tok_ident, false, "Module") ) addTerminal(st);
	if( expect(Tok_Dot, false, "Module") ) addTerminal(st);
}

void Parser::ImportDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportDecl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "ImportDecl") ) addTerminal(st);
	if( la.d_type == Tok_ColonEq ) {
		if( expect(Tok_ColonEq, false, "ImportDecl") ) addTerminal(st);
		if( expect(Tok_ident, false, "ImportDecl") ) addTerminal(st);
	}
}

void Parser::ImportList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportList, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IMPORT, false, "ImportList") ) addTerminal(st);
	ImportDecl(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "ImportList") ) addTerminal(st);
		ImportDecl(st);
	}
	if( expect(Tok_Semi, false, "ImportList") ) addTerminal(st);
}

void Parser::DeclSeq(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_DeclSeq, la); st->d_children.append(tmp); st = tmp; }
	while( la.d_type == Tok_CONST || la.d_type == Tok_TYPE || la.d_type == Tok_VAR || FIRST_ProcDecl(la.d_type) ) {
		if( la.d_type == Tok_CONST ) {
			if( expect(Tok_CONST, false, "DeclSeq") ) addTerminal(st);
			while( FIRST_ConstDecl(la.d_type) ) {
				ConstDecl(st);
				if( expect(Tok_Semi, false, "DeclSeq") ) addTerminal(st);
			}
		} else if( la.d_type == Tok_TYPE ) {
			if( expect(Tok_TYPE, false, "DeclSeq") ) addTerminal(st);
			while( FIRST_TypeDecl(la.d_type) ) {
				TypeDecl(st);
				if( expect(Tok_Semi, false, "DeclSeq") ) addTerminal(st);
			}
		} else if( la.d_type == Tok_VAR ) {
			if( expect(Tok_VAR, false, "DeclSeq") ) addTerminal(st);
			while( FIRST_VarDecl(la.d_type) ) {
				VarDecl(st);
				if( expect(Tok_Semi, false, "DeclSeq") ) addTerminal(st);
			}
		} else if( FIRST_ProcDecl(la.d_type) || la.d_type == Tok_END || la.d_type == Tok_TYPE || la.d_type == Tok_CODE || la.d_type == Tok_CONST || la.d_type == Tok_END || la.d_type == Tok_PROCEDURE || la.d_type == Tok_VAR || la.d_type == Tok_BEGIN ) {
			while( FIRST_ProcDecl(la.d_type) ) {
				ProcDecl(st);
				if( expect(Tok_Semi, false, "DeclSeq") ) addTerminal(st);
			}
		} else
			invalid("DeclSeq");
	}
}

void Parser::ObjectDeclSeq(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ObjectDeclSeq, la); st->d_children.append(tmp); st = tmp; }
	while( la.d_type == Tok_VAR || FIRST_ProcDecl(la.d_type) ) {
		if( la.d_type == Tok_VAR ) {
			if( expect(Tok_VAR, false, "ObjectDeclSeq") ) addTerminal(st);
			while( FIRST_VarDecl(la.d_type) ) {
				VarDecl(st);
				if( expect(Tok_Semi, false, "ObjectDeclSeq") ) addTerminal(st);
			}
		} else if( FIRST_ProcDecl(la.d_type) || la.d_type == Tok_VAR || la.d_type == Tok_PROCEDURE || la.d_type == Tok_END || la.d_type == Tok_BEGIN ) {
			while( FIRST_ProcDecl(la.d_type) ) {
				ProcDecl(st);
				if( expect(Tok_Semi, false, "ObjectDeclSeq") ) addTerminal(st);
			}
		} else
			invalid("ObjectDeclSeq");
	}
}

void Parser::ConstDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstDecl, la); st->d_children.append(tmp); st = tmp; }
	IdentDef(st);
	if( expect(Tok_Eq, false, "ConstDecl") ) addTerminal(st);
	ConstExpr(st);
}

void Parser::TypeDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_TypeDecl, la); st->d_children.append(tmp); st = tmp; }
	IdentDef(st);
	if( expect(Tok_Eq, false, "TypeDecl") ) addTerminal(st);
	Type(st);
}

void Parser::VarDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_VarDecl, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "VarDecl") ) addTerminal(st);
	Type(st);
}

void Parser::Assembler(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Assembler, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_CODE, false, "Assembler") ) addTerminal(st);
}

void Parser::ProcDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcDecl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_PROCEDURE, false, "ProcDecl") ) addTerminal(st);
	if( FIRST_ProcHead(la.d_type) ) {
		ProcHead(st);
		if( expect(Tok_Semi, false, "ProcDecl") ) addTerminal(st);
		DeclSeq(st);
		if( FIRST_Body(la.d_type) || FIRST_Assembler(la.d_type) ) {
			if( FIRST_Body(la.d_type) ) {
				Body(st);
			} else if( FIRST_Assembler(la.d_type) ) {
				Assembler(st);
			} else
				invalid("ProcDecl");
		}
		if( expect(Tok_END, false, "ProcDecl") ) addTerminal(st);
		if( expect(Tok_ident, false, "ProcDecl") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "ProcDecl") ) addTerminal(st);
		ProcHead(st);
	} else
		invalid("ProcDecl");
}

void Parser::ProcHead(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcHead, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
	if( la.d_type == Tok_Star || la.d_type == Tok_Amp || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Star ) {
			if( expect(Tok_Star, false, "ProcHead") ) addTerminal(st);
		} else if( la.d_type == Tok_Amp ) {
			if( expect(Tok_Amp, false, "ProcHead") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "ProcHead") ) addTerminal(st);
		} else
			invalid("ProcHead");
	}
	IdentDef(st);
	if( FIRST_FormalPars(la.d_type) ) {
		FormalPars(st);
	}
}

void Parser::SysFlag(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_SysFlag, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrack, false, "SysFlag") ) addTerminal(st);
	if( expect(Tok_ident, false, "SysFlag") ) addTerminal(st);
	if( expect(Tok_Rbrack, false, "SysFlag") ) addTerminal(st);
}

void Parser::FormalPars(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalPars, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "FormalPars") ) addTerminal(st);
	if( FIRST_FPSection(la.d_type) ) {
		FPSection(st);
		while( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "FormalPars") ) addTerminal(st);
			FPSection(st);
		}
	}
	if( expect(Tok_Rpar, false, "FormalPars") ) addTerminal(st);
	if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "FormalPars") ) addTerminal(st);
		Qualident(st);
	}
}

void Parser::FPSection(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FPSection, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_VAR ) {
		if( expect(Tok_VAR, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "FPSection") ) addTerminal(st);
		if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_Colon, false, "FPSection") ) addTerminal(st);
	Type(st);
}

void Parser::ArrayType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ArrayType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ARRAY, false, "ArrayType") ) addTerminal(st);
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
	if( FIRST_ConstExpr(la.d_type) ) {
		ConstExpr(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "ArrayType") ) addTerminal(st);
			ConstExpr(st);
		}
	}
	if( expect(Tok_OF, false, "ArrayType") ) addTerminal(st);
	Type(st);
}

void Parser::RecordType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RecordType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_RECORD, false, "RecordType") ) addTerminal(st);
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
	if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "RecordType") ) addTerminal(st);
		Qualident(st);
		if( expect(Tok_Rpar, false, "RecordType") ) addTerminal(st);
	}
	if( FIRST_FieldList(la.d_type) ) {
		FieldList(st);
	}
	if( expect(Tok_END, false, "RecordType") ) addTerminal(st);
}

void Parser::PointerType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_PointerType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_POINTER, false, "PointerType") ) addTerminal(st);
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
	if( expect(Tok_TO, false, "PointerType") ) addTerminal(st);
	Type(st);
}

void Parser::ObjectType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ObjectType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_OBJECT, false, "ObjectType") ) addTerminal(st);
	if( FIRST_SysFlag(la.d_type) || la.d_type == Tok_Lpar || FIRST_ObjectDeclSeq(la.d_type) || FIRST_Body(la.d_type) || la.d_type == Tok_END ) {
		if( FIRST_SysFlag(la.d_type) ) {
			SysFlag(st);
		}
		if( la.d_type == Tok_Lpar ) {
			if( expect(Tok_Lpar, false, "ObjectType") ) addTerminal(st);
			Qualident(st);
			if( expect(Tok_Rpar, false, "ObjectType") ) addTerminal(st);
		}
		ObjectDeclSeq(st);
		if( FIRST_Body(la.d_type) ) {
			Body(st);
		}
		if( expect(Tok_END, false, "ObjectType") ) addTerminal(st);
		if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ObjectType") ) addTerminal(st);
		}
	}
}

void Parser::ProcedureType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_PROCEDURE, false, "ProcedureType") ) addTerminal(st);
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
	if( FIRST_Attributes(la.d_type) ) {
		Attributes(st);
	}
	if( FIRST_FormalPars(la.d_type) ) {
		FormalPars(st);
	}
}

void Parser::AliasType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_AliasType, la); st->d_children.append(tmp); st = tmp; }
	Qualident(st);
}

void Parser::Type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Type, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_AliasType(la.d_type) ) {
		AliasType(st);
	} else if( FIRST_ArrayType(la.d_type) ) {
		ArrayType(st);
	} else if( FIRST_RecordType(la.d_type) ) {
		RecordType(st);
	} else if( FIRST_PointerType(la.d_type) ) {
		PointerType(st);
	} else if( FIRST_ObjectType(la.d_type) ) {
		ObjectType(st);
	} else if( FIRST_ProcedureType(la.d_type) ) {
		ProcedureType(st);
	} else
		invalid("Type");
}

void Parser::FieldDecl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldDecl, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_IdentList(la.d_type) ) {
		IdentList(st);
		if( expect(Tok_Colon, false, "FieldDecl") ) addTerminal(st);
		Type(st);
	}
}

void Parser::FieldList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldList, la); st->d_children.append(tmp); st = tmp; }
	FieldDecl(st);
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "FieldList") ) addTerminal(st);
		FieldDecl(st);
	}
}

void Parser::Body(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Body, la); st->d_children.append(tmp); st = tmp; }
	StatBlock(st);
}

void Parser::Attributes(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Attributes, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrace, false, "Attributes") ) addTerminal(st);
	if( FIRST_Attribute(la.d_type) ) {
		Attribute(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "Attributes") ) addTerminal(st);
			Attribute(st);
		}
	}
	if( expect(Tok_Rbrace, false, "Attributes") ) addTerminal(st);
}

void Parser::Attribute(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Attribute, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "Attribute") ) addTerminal(st);
	if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "Attribute") ) addTerminal(st);
		ConstExpr(st);
		if( expect(Tok_Rpar, false, "Attribute") ) addTerminal(st);
	}
}

void Parser::StatBlock(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StatBlock, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_BEGIN, false, "StatBlock") ) addTerminal(st);
	if( FIRST_Attributes(la.d_type) ) {
		Attributes(st);
	}
	if( FIRST_StatSeq(la.d_type) ) {
		StatSeq(st);
	}
}

void Parser::StatSeq(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StatSeq, la); st->d_children.append(tmp); st = tmp; }
	Statement(st);
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "StatSeq") ) addTerminal(st);
		Statement(st);
	}
}

void Parser::AssigOrCall(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_AssigOrCall, la); st->d_children.append(tmp); st = tmp; }
	Designator(st);
	if( la.d_type == Tok_ColonEq ) {
		if( expect(Tok_ColonEq, false, "AssigOrCall") ) addTerminal(st);
		Expr(st);
	}
}

void Parser::IfStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IfStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IF, false, "IfStat") ) addTerminal(st);
	Expr(st);
	if( expect(Tok_THEN, false, "IfStat") ) addTerminal(st);
	StatSeq(st);
	while( la.d_type == Tok_ELSIF ) {
		if( expect(Tok_ELSIF, false, "IfStat") ) addTerminal(st);
		Expr(st);
		if( expect(Tok_THEN, false, "IfStat") ) addTerminal(st);
		StatSeq(st);
	}
	if( la.d_type == Tok_ELSE ) {
		if( expect(Tok_ELSE, false, "IfStat") ) addTerminal(st);
		StatSeq(st);
	}
	if( expect(Tok_END, false, "IfStat") ) addTerminal(st);
}

void Parser::CaseStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_CaseStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_CASE, false, "CaseStat") ) addTerminal(st);
	Expr(st);
	if( la.d_type == Tok_DO ) {
		if( expect(Tok_DO, false, "CaseStat") ) addTerminal(st);
	} else if( la.d_type == Tok_OF ) {
		if( expect(Tok_OF, false, "CaseStat") ) addTerminal(st);
	} else
		invalid("CaseStat");
	Case(st);
	while( la.d_type == Tok_Bar ) {
		if( expect(Tok_Bar, false, "CaseStat") ) addTerminal(st);
		Case(st);
	}
	if( la.d_type == Tok_ELSE ) {
		if( expect(Tok_ELSE, false, "CaseStat") ) addTerminal(st);
		StatSeq(st);
	}
	if( expect(Tok_END, false, "CaseStat") ) addTerminal(st);
}

void Parser::WhileStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WhileStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WHILE, false, "WhileStat") ) addTerminal(st);
	Expr(st);
	if( expect(Tok_DO, false, "WhileStat") ) addTerminal(st);
	StatSeq(st);
	if( expect(Tok_END, false, "WhileStat") ) addTerminal(st);
}

void Parser::RepeatStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RepeatStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_REPEAT, false, "RepeatStat") ) addTerminal(st);
	StatSeq(st);
	if( expect(Tok_UNTIL, false, "RepeatStat") ) addTerminal(st);
	Expr(st);
}

void Parser::ForStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ForStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_FOR, false, "ForStat") ) addTerminal(st);
	if( expect(Tok_ident, false, "ForStat") ) addTerminal(st);
	if( expect(Tok_ColonEq, false, "ForStat") ) addTerminal(st);
	Expr(st);
	if( expect(Tok_TO, false, "ForStat") ) addTerminal(st);
	Expr(st);
	if( la.d_type == Tok_BY ) {
		if( expect(Tok_BY, false, "ForStat") ) addTerminal(st);
		ConstExpr(st);
	}
	if( expect(Tok_DO, false, "ForStat") ) addTerminal(st);
	StatSeq(st);
	if( expect(Tok_END, false, "ForStat") ) addTerminal(st);
}

void Parser::LoopStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LoopStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_LOOP, false, "LoopStat") ) addTerminal(st);
	StatSeq(st);
	if( expect(Tok_END, false, "LoopStat") ) addTerminal(st);
}

void Parser::WithStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WithStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WITH, false, "WithStat") ) addTerminal(st);
	Qualident(st);
	if( expect(Tok_Colon, false, "WithStat") ) addTerminal(st);
	Qualident(st);
	if( expect(Tok_DO, false, "WithStat") ) addTerminal(st);
	StatSeq(st);
	if( expect(Tok_END, false, "WithStat") ) addTerminal(st);
}

void Parser::ReturnStat(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ReturnStat, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_RETURN, false, "ReturnStat") ) addTerminal(st);
	if( FIRST_Expr(la.d_type) ) {
		Expr(st);
	}
}

void Parser::Statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_AssigOrCall(la.d_type) || FIRST_IfStat(la.d_type) || FIRST_CaseStat(la.d_type) || FIRST_WhileStat(la.d_type) || FIRST_RepeatStat(la.d_type) || FIRST_ForStat(la.d_type) || FIRST_LoopStat(la.d_type) || FIRST_WithStat(la.d_type) || la.d_type == Tok_EXIT || FIRST_ReturnStat(la.d_type) || FIRST_StatBlock(la.d_type) ) {
		if( FIRST_AssigOrCall(la.d_type) ) {
			AssigOrCall(st);
		} else if( FIRST_IfStat(la.d_type) ) {
			IfStat(st);
		} else if( FIRST_CaseStat(la.d_type) ) {
			CaseStat(st);
		} else if( FIRST_WhileStat(la.d_type) ) {
			WhileStat(st);
		} else if( FIRST_RepeatStat(la.d_type) ) {
			RepeatStat(st);
		} else if( FIRST_ForStat(la.d_type) ) {
			ForStat(st);
		} else if( FIRST_LoopStat(la.d_type) ) {
			LoopStat(st);
		} else if( FIRST_WithStat(la.d_type) ) {
			WithStat(st);
		} else if( la.d_type == Tok_EXIT ) {
			if( expect(Tok_EXIT, false, "Statement") ) addTerminal(st);
		} else if( FIRST_ReturnStat(la.d_type) ) {
			ReturnStat(st);
		} else if( FIRST_StatBlock(la.d_type) ) {
			StatBlock(st);
			if( expect(Tok_END, false, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
	}
}

void Parser::Case(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Case, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_CaseLabels(la.d_type) ) {
		CaseLabels(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "Case") ) addTerminal(st);
			CaseLabels(st);
		}
		if( expect(Tok_Colon, false, "Case") ) addTerminal(st);
		StatSeq(st);
	}
}

void Parser::CaseLabels(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_CaseLabels, la); st->d_children.append(tmp); st = tmp; }
	ConstExpr(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "CaseLabels") ) addTerminal(st);
		ConstExpr(st);
	}
}

void Parser::ConstExpr(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstExpr, la); st->d_children.append(tmp); st = tmp; }
	Expr(st);
}

void Parser::Expr(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Expr, la); st->d_children.append(tmp); st = tmp; }
	SimpleExpr(st);
	if( FIRST_Relation(la.d_type) ) {
		Relation(st);
		SimpleExpr(st);
	}
}

void Parser::SimpleExpr(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_SimpleExpr, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "SimpleExpr") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "SimpleExpr") ) addTerminal(st);
		} else
			invalid("SimpleExpr");
	}
	Term(st);
	while( FIRST_AddOp(la.d_type) ) {
		AddOp(st);
		Term(st);
	}
}

void Parser::Term(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Term, la); st->d_children.append(tmp); st = tmp; }
	Factor(st);
	while( FIRST_MulOp(la.d_type) ) {
		MulOp(st);
		Factor(st);
	}
}

void Parser::Factor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Factor, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Designator(la.d_type) ) {
		Designator(st);
	} else if( FIRST_number(la.d_type) ) {
		number(st);
	} else if( la.d_type == Tok_hexchar ) {
		if( expect(Tok_hexchar, false, "Factor") ) addTerminal(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "Factor") ) addTerminal(st);
	} else if( la.d_type == Tok_NIL ) {
		if( expect(Tok_NIL, false, "Factor") ) addTerminal(st);
	} else if( FIRST_Set(la.d_type) ) {
		Set(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "Factor") ) addTerminal(st);
		Expr(st);
		if( expect(Tok_Rpar, false, "Factor") ) addTerminal(st);
	} else if( la.d_type == Tok_Tilde ) {
		if( expect(Tok_Tilde, false, "Factor") ) addTerminal(st);
		Factor(st);
	} else
		invalid("Factor");
}

void Parser::Set(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Set, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrace, false, "Set") ) addTerminal(st);
	if( FIRST_Element(la.d_type) ) {
		Element(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "Set") ) addTerminal(st);
			Element(st);
		}
	}
	if( expect(Tok_Rbrace, false, "Set") ) addTerminal(st);
}

void Parser::Element(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Element, la); st->d_children.append(tmp); st = tmp; }
	Expr(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "Element") ) addTerminal(st);
		Expr(st);
	}
}

void Parser::Relation(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Relation, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Hash ) {
		if( expect(Tok_Hash, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Lt ) {
		if( expect(Tok_Lt, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Leq ) {
		if( expect(Tok_Leq, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Gt ) {
		if( expect(Tok_Gt, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Geq ) {
		if( expect(Tok_Geq, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_IN ) {
		if( expect(Tok_IN, false, "Relation") ) addTerminal(st);
	} else if( la.d_type == Tok_IS ) {
		if( expect(Tok_IS, false, "Relation") ) addTerminal(st);
	} else
		invalid("Relation");
}

void Parser::MulOp(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_MulOp, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "MulOp") ) addTerminal(st);
	} else if( la.d_type == Tok_DIV ) {
		if( expect(Tok_DIV, false, "MulOp") ) addTerminal(st);
	} else if( la.d_type == Tok_MOD ) {
		if( expect(Tok_MOD, false, "MulOp") ) addTerminal(st);
	} else if( la.d_type == Tok_Slash ) {
		if( expect(Tok_Slash, false, "MulOp") ) addTerminal(st);
	} else if( la.d_type == Tok_Amp ) {
		if( expect(Tok_Amp, false, "MulOp") ) addTerminal(st);
	} else
		invalid("MulOp");
}

void Parser::AddOp(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_AddOp, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "AddOp") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "AddOp") ) addTerminal(st);
	} else if( la.d_type == Tok_OR ) {
		if( expect(Tok_OR, false, "AddOp") ) addTerminal(st);
	} else
		invalid("AddOp");
}

void Parser::Designator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Designator, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "Designator") ) addTerminal(st);
	while( FIRST_Selector(la.d_type) ) {
		Selector(st);
	}
}

void Parser::Selector(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Selector, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_Dot && peek(2).d_type == Tok_ident )  ) {
		if( expect(Tok_Dot, false, "Selector") ) addTerminal(st);
		if( expect(Tok_ident, false, "Selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Lbrack ) {
		if( expect(Tok_Lbrack, false, "Selector") ) addTerminal(st);
		ExprList(st);
		if( expect(Tok_Rbrack, false, "Selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "Selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "Selector") ) addTerminal(st);
		if( FIRST_ExprList(la.d_type) ) {
			ExprList(st);
		}
		if( expect(Tok_Rpar, false, "Selector") ) addTerminal(st);
	} else
		invalid("Selector");
}

void Parser::ExprList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ExprList, la); st->d_children.append(tmp); st = tmp; }
	Expr(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "ExprList") ) addTerminal(st);
		Expr(st);
	}
}

void Parser::IdentList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IdentList, la); st->d_children.append(tmp); st = tmp; }
	IdentDef(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "IdentList") ) addTerminal(st);
		IdentDef(st);
	}
}

void Parser::Qualident(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Qualident, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Dot )  ) {
		if( expect(Tok_ident, false, "Qualident") ) addTerminal(st);
		if( expect(Tok_Dot, false, "Qualident") ) addTerminal(st);
		if( expect(Tok_ident, false, "Qualident") ) addTerminal(st);
	} else if( la.d_type == Tok_ident ) {
		if( expect(Tok_ident, false, "Qualident") ) addTerminal(st);
	} else
		invalid("Qualident");
}

void Parser::IdentDef(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IdentDef, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "IdentDef") ) addTerminal(st);
	if( la.d_type == Tok_Star || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Star ) {
			if( expect(Tok_Star, false, "IdentDef") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "IdentDef") ) addTerminal(st);
		} else
			invalid("IdentDef");
	}
	if( FIRST_SysFlag(la.d_type) ) {
		SysFlag(st);
	}
}

void Parser::number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_number, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_integer ) {
		if( expect(Tok_integer, false, "number") ) addTerminal(st);
	} else if( la.d_type == Tok_real ) {
		if( expect(Tok_real, false, "number") ) addTerminal(st);
	} else
		invalid("number");
}

