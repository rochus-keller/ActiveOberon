This is the C++ version of the ActiveOberon parser migrated to Go. The idea is to translate the Oberon AST to the Go AST and then use the regular Go optimizer and code generator infrastructure to implement a full ActiveOberon compiler.

Go seems particularly suited because it has an integrated GC and everything required to implement the active objects and monitors including signal/await. It would also be suited to implement Oberon+ including the envisioned concurrency concept. 

In principle the compiler could directly implement Go bytecode ("assembler"); but the latter seems to be not officially documented and also volatile; on the other hand the Go AST has an official API and is well documented and also used by the official Go compiler.

The downside of Go is the fact that even after eight years, the plugin concept is still not available on Windows; applications depending on plugins are therefore limited to Unix systems (including macOS). Plugins would be a good candidate to implement Oberon modules which are for one part the compilation units of the language, but for the other part also the linking and loading units. A significant portion of the Oberon System is dedicated to dynamically loading (and unloading) modules at runtime. If the Oberon System should be migrated to the Go based architecture, plugins would be a necessary precondition to allow users of the Oberon system to compile and run their own modules. It is already a significant restriction that Go plugins cannot be unloaded once they are in memory, which limits the usefulness of the technology as a basis for the Oberon System. 

The resulting Go based compiler would still be useful for all applications where static compilation is appropriate (i.e. the same applications Go is used for). Even providing a Go version with a more Pascal/Oberon like syntax looks like a valuable goal.

If we compare the envisioned Go based approach with ECMA-335 CLI, the performance seems equivalent (Go applications are about factor 2 to 4 slower than equivalent C applications, and CLI applications are about factor 1.5 to 3 slower based on the available Are-we-fast-yet measurement results). In contrast to Go, CLI is very well suited for dynamic loading (and unloading) of assemblies and there is also a GC and concurrency. So, each approach therefore has its specific advantages and disadvantages, and how these are weighted depends on the use-case.
